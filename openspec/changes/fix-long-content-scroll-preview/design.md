## 上下文

当前预览区采用 Obsidian ItemView + React + Shadow DOM 的复合结构。虽然主题切换与内容渲染已可用，但长文场景下仍会出现“只能看到一部分、无法持续滚动”的问题。该问题与内容本身无关，核心在于多层容器的高度链路与滚动容器职责不稳定：任一父层高度塌陷或容器选择漂移，都会导致滚动失效。

## 目标 / 非目标

**目标：**
- 建立稳定的“单一纵向滚动容器”策略，保证长文可完整浏览到底。
- 使滚动能力对主题切换、工具栏显隐、窗口尺寸变化具备鲁棒性。
- 为复杂内容（图片、代码块、Mermaid）提供一致的滚动行为。
- 形成可回归验证的标准，避免后续样式调整引入回归。

**非目标：**
- 不引入新的分页阅读交互（例如上下翻页按钮）。
- 不改造主题视觉风格，仅保证功能一致性。
- 不在本次变更内处理与滚动无关的 AI/模板业务能力。

## 决策

### 决策 1：采用“单一滚动容器”模型
- 选择：将预览展示区明确为唯一纵向滚动容器，其他父层仅负责布局，不承担滚动。
- 原因：多滚动容器叠加会造成滚轮事件争夺与滚动终止位置不确定。
- 备选方案：
  - 允许父层与子层同时滚动：实现简单，但易出现滚动冲突与“滚不动”假象。
  - 改为分页交互：不符合当前用户要求（需要自然滚动）。

### 决策 2：固定高度链路并强制最小高度约束
- 选择：在 ItemView 容器、React 容器、Shadow 容器、预览主容器上统一使用 `height: 100%` 与 `min-height: 0`，并避免 `overflow` 误配置。
- 原因：这是 Flex 布局下长内容可滚动的必要条件，缺失任一层都会导致滚动容器被内容撑坏或被父层裁切。
- 备选方案：
  - 仅在滚动容器做 `overflow-y: auto`：在父层高度不稳定时无效。
  - 用 JS 动态计算高度：维护成本高，且在 Obsidian 视图变化时不可靠。

### 决策 3：主题切换后保持滚动语义不变
- 选择：主题只影响配色与视觉，不允许覆盖滚动容器的 `overflow`、`height`、`min-height` 等关键布局属性。
- 原因：避免“主题可切换但功能被破坏”的隐式回归。
- 备选方案：
  - 由每个主题自行声明滚动行为：灵活但高风险，难以统一验收。

### 决策 4：将复杂内容渲染视为滚动一致性测试基线
- 选择：把 Mermaid、长代码块、大图作为标准回归样本。
- 原因：这三类内容最容易触发高度异常和滚动链路中断。
- 备选方案：
  - 仅用纯文本回归：无法发现真实生产问题。

## 风险 / 权衡

- [风险] Obsidian 版本或布局结构差异导致容器选择策略失效  
  → 缓解措施：优先语义化选择稳定容器，并保留安全回退路径。

- [风险] 后续主题样式覆盖关键滚动属性  
  → 缓解措施：把关键布局属性收敛到高优先级基础层，并加入回归检查。

- [风险] 复杂内容在渲染时短暂改变高度造成“跳动”  
  → 缓解措施：在渲染完成后触发一次稳定化检查，保证滚动容器仍可达底部。

## Migration Plan

1. 明确并固定滚动容器职责，梳理父子容器高度链路。  
2. 统一关键布局约束并移除冲突交互（分页按钮/滚轮分页拦截）。  
3. 对主题切换、工具栏显隐、宽度变化、复杂内容场景执行回归。  
4. 发布后通过用户样例长文进行验收；若异常，按容器链路逐层定位回滚。  

回滚策略：
- 保留变更前构建产物版本；若出现大面积滚动回归，回滚到上一稳定版本并保留日志以便二次修复。

## Open Questions

- 是否需要在设置中暴露“滚动灵敏度/平滑滚动”开关，还是保持固定行为以降低复杂度？
- 是否为预览区新增运行时诊断信息（如滚动容器高度与可滚动状态）以便快速排障？
